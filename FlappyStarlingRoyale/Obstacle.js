/**
 * Generated by Apache Royale Compiler from Obstacle.as
 * Obstacle
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('Obstacle');
/* Royale Dependency List: Game*/




/**
 * @constructor
 * @extends {starling.display.Sprite}
 * @param {number} gapHeight
 */
Obstacle = function(gapHeight) {
  Obstacle.base(this, 'constructor');
  var /** @type {starling.textures.Texture} */ topTexture = Game.assets.getTexture("obstacle-top");
  var /** @type {starling.textures.Texture} */ bottomTexture = Game.assets.getTexture("obstacle-bottom");
  this.Obstacle__radius = topTexture.width / 2;
  this.Obstacle__gapHeight = gapHeight;
  var /** @type {starling.display.Image} */ top = new starling.display.Image(topTexture);
  top.pixelSnapping = true;
  top.pivotX = this.Obstacle__radius;
  top.pivotY = topTexture.height - this.Obstacle__radius;
  top.y = gapHeight / -2;
  var /** @type {starling.display.Image} */ bottom = new starling.display.Image(bottomTexture);
  bottom.pixelSnapping = true;
  bottom.pivotX = this.Obstacle__radius;
  bottom.pivotY = this.Obstacle__radius;
  bottom.y = gapHeight / 2;
  this.addChild(top);
  this.addChild(bottom);
};
goog.inherits(Obstacle, starling.display.Sprite);


/**
 * @private
 * @type {boolean}
 */
Obstacle.prototype.Obstacle__passed = false;


/**
 * @private
 * @type {number}
 */
Obstacle.prototype.Obstacle__radius = NaN;


/**
 * @private
 * @type {number}
 */
Obstacle.prototype.Obstacle__gapHeight = NaN;


/**
 * @param {number} birdX
 * @param {number} birdY
 * @param {number} birdRadius
 * @return {boolean}
 */
Obstacle.prototype.collidesWithBird = function(birdX, birdY, birdRadius) {
  var /** @type {number} */ distY = NaN;
  if (birdX + birdRadius < this.x - this.Obstacle__radius || birdX - birdRadius > this.x + this.Obstacle__radius)
    return false;
  var /** @type {number} */ bottomY = this.y + this.Obstacle__gapHeight / 2;
  var /** @type {number} */ topY = this.y - this.Obstacle__gapHeight / 2;
  if (birdY < topY || birdY > bottomY)
    return true;
  var /** @type {number} */ distX = this.x - birdX;
  //var /** @type {number} */ distY = NaN;
  distY = topY - birdY;
  if (Math.sqrt(distX * distX + distY * distY) < this.Obstacle__radius + birdRadius)
    return true;
  distY = bottomY - birdY;
  if (Math.sqrt(distX * distX + distY * distY) < this.Obstacle__radius + birdRadius)
    return true;
  return false;
};


/**
 * @nocollapse
 * @export
 * @type {boolean}
 */
Obstacle.prototype.passed;


Obstacle.prototype.get__passed = function() {
  return this.Obstacle__passed;
};


Obstacle.prototype.set__passed = function(value) {
  this.Obstacle__passed = value;
};


Object.defineProperties(Obstacle.prototype, /** @lends {Obstacle.prototype} */ {
/**
 * @type {boolean}
 */
passed: {
get: Obstacle.prototype.get__passed,
set: Obstacle.prototype.set__passed}}
);


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
Obstacle.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'Obstacle', qName: 'Obstacle', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
Obstacle.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    accessors: function () {
      return {
        'passed': { type: 'Boolean', access: 'readwrite', declaredBy: 'Obstacle'}
      };
    },
    methods: function () {
      return {
        'Obstacle': { type: '', declaredBy: 'Obstacle', parameters: function () { return [ 'Number', false ]; }},
        'collidesWithBird': { type: 'Boolean', declaredBy: 'Obstacle', parameters: function () { return [ 'Number', false ,'Number', false ,'Number', false ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
Obstacle.prototype.ROYALE_COMPILE_FLAGS = 9;

//# sourceMappingURL=./Obstacle.js.map
